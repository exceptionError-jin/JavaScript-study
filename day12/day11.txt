

자바스크립트의 스레드 (코드를 처리하는 일꾼)
자바스크립트는 싱글 스레드

a ... (3초)
b ... (2초)
c ... (5초)
d ... (30초)
e ... (8초)
main ... (5초) --- 53초

싱글 쓰레드인 자바스크립트의 특징은
현재 실행중인 태스크(기능, 구간, 섹션)가 종료되어야만 다음 태스크를 실행합니다.
이러한 특징 때문이 처리 시간이 지연되는 함수의 경우 굉장히 비효율적

따라서 자바스크립트는 이벤트 루프를 활용하여 기존의 태스크가 종료되지 않아도
다음 태스크를 곧바로 실행하는 방식인 비동기 처리방식을 도입 하였습니다.

동기 vs 비동기

동기는 코드를 순차적인 흐름으로 진행

----------------------------------------------------------------------------------------------------------

* 대표적인 비동기 함수
setTimeOut, setInterval, Promise

-----------------------------------------------------------------------------------------------------------

비동기 처리

비동기 처리 시간이 각각 다르기 때문에 결과를 예상할 수 없음
따라서 결과에 따라 다음 함수(비동기 이후 실행된 동기적이 함수)를 실행시키기 위하여 비동기를 동기적으로 처리

(1) call back

function 비동기 (callback) { ---> 비동기 함수

    setTimeOut(()=> {
        console.log("하나")
        callback(
            setTimeOut(()=>{
                console.log("둘")
            },1000)
        ) ------- > 비동기
    }, 1000)
    
} --------------------------------------------------> 콜백 지옥


function callback () { ---> 비동기 이후에 실행되어야 함
    setTimeOut(()=>{
        console.log("콜백"ㄴ)
    }, 1000)
}

---------------------------------------------------->

(2) promise
ES6에 도입, new 연산자와 함꼐 호출하고 인자로 콜백을 받습니다.
Promise는 호출 시에 바로 실행은 되지만 그 안에 resolve와 recject가 둘중 하나가 호출되기 전에는
then과 catch로 넘어가지 않습니다.

then --> promise 성공했을 때
catch --> promise 실패했을 때

비동기는 항상 성공 할까요

ex)

let num3
const result = new Promise((resolve, reject) => {
    비동기 함수 ...
    num=2
    resolve(num)


    resolve(성공 인자)
    reject(실패 인자)

}).then((인자) => {
    console.log(인자) // 성공 인자
    d(인자)
})
.catch((인자) => {
    console.log(인자) // 실패 인자
})


d(num)


(3) async await
    Promise로 비동기 처리를 한다고 하더라도, 콜백 지옥이 연상되는 것은 마찬가지
    비동기를 아예 동기적인 흐름 처리로 만들어버리자


    async를 통해 함수를 promise 변환
    await을 통해 해당 함수가 실행될 때까지 (promise가 resolve, rject) 대기 

    

    async function a(){
    }

    const a = async () =>  {
        try {

            const result = await new Promise(...) 
            console.log(result) --> return promise resolve

        } catech(err) {

            console.log(err) --> return promise reject
            // 예외 상황 처리문
        }
    }

----------------------------------------------------------------------------------------------------------

백엔드랑 API로 데이터 통신
    https://jsonplaceholder.typicode.com

----------------------------------------------------------------------------------------------------------

ajax?
    본래 의미는 Javascript를 비동기 통신, 클라이언트와 서버 간의 데이터를 주고 받는 기술


    www.naver.com <---- html,css,js
                  ----> com/login <--- html, css, js

----------------------------------------------------------------------------------------------------------

* axios, fetch

    기존의 Web에서는 비동기 요청을 보내기 위해 XML HTTP REQUEST(XHR) 객체를 생성했어야함
    그러나 이러한 XHR은 요청의 상태나 변경에 따라 개발자의 의도에 맞게 사용하기는 적합지 않았음
    따라서 이를 보완하기 위하여 HTTP 요청에 최적화 되고 추상화도 되었이는 API들이 생겨나기 시작함

    대표적으로 axios, fetch

    fetch
        ES6부터 자바스크립트의 빌트인 객체로 내장 되어있음, 안정성이 뛰어남
        Promise 기반으로 만들어져 코드 또한 간편함


        ex)
            fetch(url, option).then().catch()

    단 단점이 있다면 데이터 요청 및 응답데이터 수신 시 JSON를 데이터를 받아올 수 없기 때문에
    파싱 작업을 해야함 

    ex)

    reoponse.json()
    // string -> json 

    JSON.stringfy()
    // json - string

------------------------------------------------------------------------------------------------------------

   *  axios

   빌트인 객체x
   CDN으로 라이브러리를 가지고 와서 사용, Promise 기반

   크로스브라우징에 신경을 썼음 거의 모든 브라우저 호환
   다양한 기능을 기원 (timeout, interceoptor ...)

   https://axios-http.com/kr/docs/intro

   라이브러리 설치에 의한 의존성 상승

------------------------------------------------------------------------------------------------------------
    
    location 객체 
        자바스크립트의 window가 갖는 빌트인
        그러나 window는 생략이 가능
        현재 인터넷 창의 URL(주소)를 나타내는 객체

        메서드
            replace = 인자로 전달된 주소로 이동, history에 남지않습니다.
            reload = 새로고침
            assign = 인자로 전달된 새로운 주소로 이동, history가 남습니다.

        속성
            hash = 도메인에 #뒤에 붙은 값을 가지고옴
                    ex) www.seongyong.com#blog
                    ==> blog

            hostname = URL의 도메인
            origin = 프로토콜 + URL 도메인 + 포트번호
            pathname = 원본 주소 제외한 나머지 경로
                    ex) www.seongyong.com/post
                    ==> post

            port = 포트번호
                    서버 -> 호텔
                    포트 -> 방

            protocol = http/https
            
            ** search = URL에 추가된 쿼리 스트링을 가지고 옴
                    ex) www.seongyong.com/goods?good_idx=380502
                    good_idx = 380502

                        - 이전 페이지의 대한 값을 다음 페이제이서 가지고 있을 수 없기 때문에
                        주소로 통해 데이터를 전달

                        - 같은 페이지 내라고 하더라도 사용자에게 현재 위치를 알려주고 주소의
                        history를 남겨 뒤로가기를 지원하기 위하여 전달

            * href = 현재의 URL을 반환, 해당 속성의 값을 바꿔주면 페이지가 이동


    histroy 객체
        사용자가 방문한 URL의 기록
        이전 페이지 혹은 다음 페이지로 이동 시킬 수 있는 객체


------------------------------------------------------------------------------------------------------------

    과제 

        1. list 페이지
            https://jsonplaceholder.typicode.com/posts를 통해 20개의 게시글 불러오기

        2. 각 게시글 클릭 시
            해당 게시글의 idx를 주소로 보내 해당 idx에 맞는 게시글의 상세 페이지 및 댓글을
            조회하여 사용자에게 보이도록 해주세요

        페이지: list.html / detail.html
        요구사항:
            list.html
                20개의 게시글 데이이터 (제목,내용,idx)
            detail.html
                선택된 게시글의 상세, 댓글 내용 